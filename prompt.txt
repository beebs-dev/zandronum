Embed the client in a browser using emscripten. Write a Dockerfile to build this image at thavlik/zandronum:latest and DO NOT build outside of docker. Make the game render for the full page. When the page is loaded with query ?q=<game_id> I want to automatically join the game by hitting this auth endpoint:
GET `https://api.synapse.beebs.dev/room/${gameId}/join`
to yield the credentials for webrtc. Like this:

```js
async function join(serverArg) {
          // serverArg may be either:
          //  - full join URL: https://api.synapse.beebs.dev/room/<uuid>/join
          //  - room UUID: <uuid>
          let arg = '';
          if (serverArg !== undefined && serverArg !== null) {
            arg = String(serverArg);
          }
          if (!arg) {
            const fromUrl = getGameIdFromUrl();
            if (fromUrl) arg = fromUrl;
          }
          if (!arg) {
            throw new Error('missing game id (use ?g=<uuid> or pass -net <uuid>)');
          }

          const joinUrl = (arg.startsWith('http://') || arg.startsWith('https://'))
            ? arg
            : `https://api.synapse.beebs.dev/room/${arg}/join`;

          // If ?name=<name> is present, forward it to the join API.
          // This lets the backend mint a token with the chosen participant name.
          let finalJoinUrl = joinUrl;
          try {
            const name = getNameFromUrl();
            if (name) {
              const u = new URL(joinUrl);
              u.searchParams.set('name', name);
              finalJoinUrl = u.toString();
            }
          } catch (_) {
            // If URL parsing fails for any reason, fall back to the raw joinUrl.
          }

          const resp = await fetch(finalJoinUrl, { method: 'GET' });
          if (!resp.ok) {
            throw new Error(`join failed: ${resp.status} ${resp.statusText}`);
          }
          const json = await resp.json();
          if (!json || typeof json.token !== 'string' || typeof json.url !== 'string') {
            throw new Error('join response missing token/url');
          }
          return { token: json.token, url: json.url };
        }
```

Then I want to connect to the server over WebRTC (the endpoint is in the `url` field of the object returned by the above join room function) Use reliable publishing for establishing the connection and unreliable/lossy for the tick packets.

See index.html for known good WebRTC connection code. 

The networking layer should be relatively thin. The UDP packets should be bubbled up to Javascript so they can be published over WebRTC. Both incoming and outgoing messages need the "udp" topic, and the client will only receive messages from the participant named "server". When a packet is received from WebRTC, send it to WASM where the existing networking code processes it just the same.