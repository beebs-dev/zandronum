<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Zandronum (Web)</title>
    <style>
      html, body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: #000;
      }
      #canvas {
        display: block;
        width: 100vw;
        height: 100vh;
        image-rendering: pixelated;
      }
      #hud {
        position: fixed;
        left: 10px;
        bottom: 10px;
        max-width: min(720px, calc(100vw - 20px));
        color: #e6edf3;
        font: 12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        background: rgba(0,0,0,0.55);
        border: 1px solid rgba(255,255,255,0.15);
        border-radius: 8px;
        padding: 8px 10px;
        pointer-events: none;
        white-space: pre-wrap;
      }
    </style>
  </head>

  <body>
    <canvas id="canvas" oncontextmenu="event.preventDefault()"></canvas>
    <div id="hud">Loading…</div>

    <!-- LiveKit JS SDK (UMD build) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/livekit-client/2.15.7/livekit-client.umd.js"></script>
    <!-- Emscripten output (generated by the Docker build) -->
    <script src="zandronum.js"></script>

    <script>
      const hud = document.getElementById('hud');
      const canvas = document.getElementById('canvas');

      // Allow the canvas to receive keyboard focus (helps SDL + pointer lock).
      try {
        canvas.tabIndex = 0;
        canvas.style.outline = 'none';
      } catch (_) {}

      function setHud(text) {
        hud.textContent = String(text ?? '');
      }

      function getParam(name) {
        try {
          const u = new URL(window.location.href);
          return u.searchParams.get(name);
        } catch {
          return null;
        }
      }

      function getGameIdFromUrl() {
        // Requested: ?q=<game_id>. Keep ?g=<uuid> as a compatibility alias.
        return getParam('q') || getParam('g');
      }

      function getNameFromUrl() {
        return getParam('name');
      }

      async function join(serverArg) {
        // serverArg may be either:
        //  - full join URL: https://api.synapse.beebs.dev/room/<uuid>/join
        //  - room UUID: <uuid>
        let arg = '';
        if (serverArg !== undefined && serverArg !== null) {
          arg = String(serverArg);
        }
        if (!arg) {
          const fromUrl = getGameIdFromUrl();
          if (fromUrl) arg = fromUrl;
        }
        if (!arg) {
          throw new Error('missing game id (use ?q=<uuid>)');
        }

        const joinUrl = (arg.startsWith('http://') || arg.startsWith('https://'))
          ? arg
          : `https://api.synapse.beebs.dev/room/${arg}/join`;

        // If ?name=<name> is present, forward it to the join API.
        let finalJoinUrl = joinUrl;
        try {
          const name = getNameFromUrl();
          if (name) {
            const u = new URL(joinUrl);
            u.searchParams.set('name', name);
            finalJoinUrl = u.toString();
          }
        } catch (_) {
          // Ignore URL parsing issues.
        }

        const resp = await fetch(finalJoinUrl, { method: 'GET' });
        if (!resp.ok) {
          throw new Error(`join failed: ${resp.status} ${resp.statusText}`);
        }
        const json = await resp.json();
        if (!json || typeof json.token !== 'string' || typeof json.url !== 'string') {
          throw new Error('join response missing token/url');
        }
        return { token: json.token, url: json.url };
      }

      function resizeCanvas(module) {
        // Match CSS pixels; SDL will handle scaling.
        const w = Math.max(1, window.innerWidth | 0);
        const h = Math.max(1, window.innerHeight | 0);
        if (module && typeof module.setCanvasSize === 'function') {
          module.setCanvasSize(w, h, false);
        } else {
          canvas.width = w;
          canvas.height = h;
        }
      }

      async function main() {
        if (!window.LivekitClient) {
          throw new Error('LiveKit SDK failed to load (LivekitClient global missing).');
        }
        if (typeof window.createZandronumModule !== 'function') {
          throw new Error('Emscripten module factory missing (createZandronumModule).');
        }

        setHud('Joining room…');
        const { token, url } = await join();

        setHud('Connecting WebRTC…');
        const room = new LivekitClient.Room({});

        // Promise that resolves on the first user gesture.
        let resolveFirstGesture;
        const firstGesture = new Promise((resolve) => { resolveFirstGesture = resolve; });

        // Chrome blocks audio + pointer lock until a user gesture.
        // Keep a persistent pointer handler so we can re-capture mouse after blur.
        let inputHandlersInstalled = false;
        let currentModule = null;

        function updatePointerLockUi() {
          const locked = document.pointerLockElement === canvas;
          canvas.style.cursor = locked ? 'none' : 'default';
        }

        function installInputHandlers() {
          if (inputHandlersInstalled) return;
          inputHandlersInstalled = true;

          document.addEventListener('pointerlockchange', updatePointerLockUi);
          updatePointerLockUi();

          const handler = async () => {
            try {
              canvas.focus?.();
            } catch (_) {}

            // Pointer lock for mouse capture.
            try {
              if (!document.pointerLockElement && canvas.requestPointerLock) {
                canvas.requestPointerLock();
              }
            } catch (_) {}

            // LiveKit audio (optional).
            try {
              await room.startAudio?.();
            } catch (_) {}

            // SDL/WebAudio (Emscripten): best-effort resume.
            try {
              const mod = currentModule;
              const ctx = mod?.SDL2?.audioContext || mod?.SDL?.audioContext || window.SDL2?.audioContext;
              if (ctx && ctx.state === 'suspended' && typeof ctx.resume === 'function') {
                await ctx.resume();
              }
            } catch (_) {}

            if (resolveFirstGesture) {
              try { resolveFirstGesture(); } catch (_) {}
              resolveFirstGesture = null;
            }
          };

          // Not once: we need to re-acquire pointer lock after tab blur.
          canvas.addEventListener('pointerdown', handler);
        }

        // Install early so LiveKit connect is always gated.
        installInputHandlers();

        // UDP queue for the WASM side to poll.
        const udpQueue = [];
        const stats = {
          wasmSendCalls: 0,
          wasmRecvCalls: 0,
          lkRecv: 0,
          lkSend: 0,
          lkSendErr: 0,
        };

        function publishUdp(u8, reliable) {
          if (!room || !room.localParticipant) return false;
          const dest = ['server'];

          // Preferred signature (LK v2): publishData(data, { reliable, topic, destinationIdentities })
          try {
            room.localParticipant.publishData(u8, {
              reliable: !!reliable,
              topic: 'udp',
              destinationIdentities: dest,
            });
            stats.lkSend++;
            return true;
          } catch (_) {
            // Fall through.
          }

          // Fallback signature:
          // publishData(data, kind, options)
          const kind = reliable
            ? LivekitClient.DataPacket_Kind.RELIABLE
            : LivekitClient.DataPacket_Kind.LOSSY;
          try {
            room.localParticipant.publishData(u8, kind, {
              topic: 'udp',
              destinationIdentities: dest,
            });
            stats.lkSend++;
            return true;
          } catch (_) {
            // Fall back to broadcasting.
          }
          try {
            room.localParticipant.publishData(u8, kind, { topic: 'udp' });
            stats.lkSend++;
            return true;
          } catch (_) {
            stats.lkSendErr++;
            return false;
          }
        }

        room.on(LivekitClient.RoomEvent.DataReceived, (payload, participant, kind, topic) => {
          // Some LiveKit publishData overloads may omit topic on the receiver.
          // Treat missing topic as UDP for this app.
          if (topic && topic !== 'udp') return;
          if ((participant?.identity ?? '') !== 'server') return;
          // payload is Uint8Array
          udpQueue.push(payload);
          stats.lkRecv++;
        });

        setHud('Click to start…');
        await firstGesture;
        setHud('Connecting WebRTC…');
        await room.connect(url, token);

        const debugEnabled = getParam('debug') === '1';

        if (debugEnabled) {
          // If this never prints, the engine likely blocks the JS event loop.
          setTimeout(() => console.log('debug: event loop still alive (pre-callMain)'), 1000);
        }

        // Debug-only: verify that LiveKit data packets reach the server/proxy
        // even if the engine never calls into the UDP bridge.
        if (debugEnabled) {
          try {
            const bytes = new TextEncoder().encode('zan-debug-ping');
            const ok = publishUdp(bytes, true);
            console.log('debug: sent zan-debug-ping ok=', ok);
          } catch (e) {
            console.warn('debug: failed to send zan-debug-ping', e);
          }
        }

        // JS transport surface consumed by src/network.cpp (EM_JS hooks).
        // IMPORTANT: this Zandronum build is MODULARIZE'd, so the C++ EM_JS
        // hooks see the *module instance*, not window.Module.
        // We attach __zanRtc onto the module instance via the factory options
        // passed to createZandronumModule().
        const zanRtc = {
          debug: debugEnabled,
          recvUdp() {
            stats.wasmRecvCalls++;
            return udpQueue.length ? udpQueue.shift() : null;
          },
          sendUdp(u8, reliable) {
            stats.wasmSendCalls++;
            publishUdp(u8, !!reliable);
          },
        };

        setHud('Starting game…');

        function tryDecodeCStringPtr(mod, ptr) {
          try {
            if (!mod || typeof ptr !== 'number' || !Number.isFinite(ptr) || ptr <= 0) return null;
            const heap = mod.HEAPU8;
            if (!heap) return null;
            // Heuristic: treat ptr as pointer to a null-terminated UTF-8 string.
            const maxLen = 4096;
            let end = ptr;
            const maxEnd = Math.min(heap.length, ptr + maxLen);
            while (end < maxEnd && heap[end] !== 0) end++;
            if (end === ptr) return '';
            if (end >= heap.length) return null;
            return new TextDecoder('utf-8', { fatal: false }).decode(heap.subarray(ptr, end));
          } catch (_) {
            return null;
          }
        }

        const zand = await window.createZandronumModule({
          noInitialRun: true,
          __zanRtc: zanRtc,
          canvas,
          onAbort: (what) => {
            const decoded = tryDecodeCStringPtr(zand, what);
            console.error('Zandronum abort:', what, typeof what, decoded ? `decoded="${decoded}"` : '');
          },
          quit: (status, toThrow) => {
            console.error('Zandronum quit:', { status, toThrowType: typeof toThrow, toThrow });
            throw toThrow;
          },
          preRun: [
            function () {
              try {
                // Ensure a writable home + XDG-ish config base exists.
                // Zandronum uses NicePath("~/.config/") on Unix.
                if (typeof FS !== 'undefined' && FS.mkdir) {
                  try { FS.mkdir('/home'); } catch (_) {}
                  try { FS.mkdir('/home/web_user'); } catch (_) {}
                  try { FS.mkdir('/home/web_user/.config'); } catch (_) {}
                }
              } catch (_) {}
            },
          ],
          print: (t) => {
            if (t !== undefined && t !== null && String(t).trim()) {
              console.log(String(t));
            }
          },
          printErr: (t) => {
            if (t !== undefined && t !== null && String(t).trim()) {
              console.error(String(t));
            }
          },
        });

        // Give input handlers access to the module instance (for resuming SDL audio).
        currentModule = zand;

        if (debugEnabled) {
          try {
            const hasFs = !!zand.FS;
            const iwadPath = '/assets/freedoom2.wad';
            const pk3Path = '/zandronum.pk3';
            const iwadExists = hasFs ? !!zand.FS.analyzePath(iwadPath).exists : false;
            const pk3Exists = hasFs ? !!zand.FS.analyzePath(pk3Path).exists : false;
            console.log('debug: FS available=', hasFs, 'iwadExists=', iwadExists, 'pk3Exists=', pk3Exists);
            if (!iwadExists) {
              console.warn('debug: missing IWAD at', iwadPath);
            }
          } catch (e) {
            console.warn('debug: FS check failed', e);
          }
        }

        resizeCanvas(zand);
        window.addEventListener('resize', () => resizeCanvas(zand));

        // Kick off the engine in client mode. The IP is a dummy; UDP is bridged over WebRTC.
        // Use the preloaded IWAD so the engine can actually start.
        try {
          zand.callMain(['-iwad', '/assets/freedoom2.wad', '-file', '/assets/doom1.wad', '-file', '/assets/sunlust.wad', '-connect', '127.0.0.1']);
        } catch (e) {
          const decoded = tryDecodeCStringPtr(zand, e);
          console.error('callMain threw:', e, typeof e, decoded ? `decoded="${decoded}"` : '');
          throw e;
        }

        if (debugEnabled) {
          // If this never prints, callMain likely never returns (busy loop / no emscripten main loop integration).
          setTimeout(() => console.log('debug: event loop still alive (post-callMain)'), 1000);
        }

        // Minimal on-screen diagnostic (only if ?debug=1).
        if (debugEnabled) {
          setInterval(() => {
            setHud(
              `wasmSend=${stats.wasmSendCalls} wasmRecv=${stats.wasmRecvCalls} lkSend=${stats.lkSend} lkSendErr=${stats.lkSendErr} lkRecv=${stats.lkRecv} udpQueue=${udpQueue.length}`
            );
          }, 250);
        } else {
          setHud('');
        }
      }

      main().catch((e) => {
        const msg = e?.stack || String(e);
        setHud(String(msg));
        console.error('main() rejected:', e, typeof e);
      });
    </script>
  </body>
</html>
