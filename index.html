<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Zandronum (Web)</title>
    <style>
      html, body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: #000;
      }
      #canvas {
        display: block;
        position: fixed;
        inset: 0;
        width: 100vw;
        height: 100vh;
        image-rendering: pixelated;
      }
      #hud {
        position: fixed;
        left: 10px;
        bottom: 10px;
        max-width: min(720px, calc(100vw - 20px));
        color: #e6edf3;
        font: 12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        background: rgba(0,0,0,0.55);
        border: 1px solid rgba(255,255,255,0.15);
        border-radius: 8px;
        padding: 8px 10px;
        pointer-events: none;
        white-space: pre-wrap;
      }
    </style>
  </head>

  <body>
    <canvas id="canvas" oncontextmenu="event.preventDefault()"></canvas>
    <div id="hud">Loading…</div>

    <!-- LiveKit JS SDK (UMD build) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/livekit-client/2.15.7/livekit-client.umd.js"></script>
    <!-- Emscripten output (generated by the Docker build) -->
    <script src="./zandronum.js"></script>

    <script>
      const hud = document.getElementById('hud');
      const canvas = document.getElementById('canvas');

      // Allow the canvas to receive keyboard focus (helps SDL + pointer lock).
      try {
        canvas.tabIndex = 0;
        canvas.style.outline = 'none';
      } catch (_) {}

      function setHud(text) {
        hud.textContent = String(text ?? '');
      }

      function getParam(name) {
        try {
          const u = new URL(window.location.href);
          return u.searchParams.get(name);
        } catch {
          return null;
        }
      }

      function getGameIdFromUrl() {
        // Requested: ?q=<game_id>. Keep ?g=<uuid> as a compatibility alias.
        return getParam('q') || getParam('g');
      }

      function extractFirstUuid(text) {
        const s = String(text ?? '');
        // Match a canonical UUID (accept any version/variant).
        const m = s.match(/[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}/);
        return m ? m[0] : null;
      }

      function getGameIdForInfoOrThrow(joinArg) {
        if (!joinArg) {
          throw new Error('missing game id (use ?q=<uuid>)');
        }
        // If joinArg is already a UUID, use it directly; otherwise try extracting one.
        const direct = extractFirstUuid(joinArg);
        if (direct) return direct;
        throw new Error('missing game id (use ?q=<uuid>)');
      }

      async function fetchGameInfo(gameId) {
        const url = `https://api.dorch.beebs.dev/game/${encodeURIComponent(String(gameId))}`;
        const resp = await fetch(url, { method: 'GET' });
        if (!resp.ok) {
          throw new Error(`game info fetch failed: ${resp.status} ${resp.statusText}`);
        }
        const json = await resp.json();
        console.log('game info json:', json);
        return json;
      }

      function extractWadIdsFromGameInfoJson(gameJson) {
        // Public GET /game/{id} returns a GameSummary (master crate):
        //   { game_id, iwad, files?: [uuid], info?: { ... } }
        // Some callers may expect these under `info`, so support both.
        const root = gameJson && typeof gameJson === 'object' ? gameJson : {};
        const maybeInfo = root.info && typeof root.info === 'object' ? root.info : null;

        const iwad = (maybeInfo && maybeInfo.iwad) ? maybeInfo.iwad : root.iwad;
        const files = (maybeInfo && maybeInfo.files) ? maybeInfo.files : root.files;

        const wadIds = [];
        if (typeof iwad === 'string' && iwad) wadIds.push(iwad);
        if (Array.isArray(files)) {
          for (const f of files) {
            if (typeof f === 'string' && f) wadIds.push(f);
          }
        }
        return wadIds;
      }

      async function resolveWadUrls(wadIds) {
        const url = 'https://api.dorch.beebs.dev/wad_urls';
        const resp = await fetch(url, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ wad_ids: wadIds }),
        });
        if (!resp.ok) {
          throw new Error(`wad_urls failed: ${resp.status} ${resp.statusText}`);
        }
        const json = await resp.json();
        console.log('wad_urls response:', json);
        return json;
      }

      function isProbablyGzip(u8) {
        try {
          return u8 && u8.length >= 2 && u8[0] === 0x1f && u8[1] === 0x8b;
        } catch (_) {
          return false;
        }
      }

      async function gunzipBytes(u8) {
        if (typeof DecompressionStream !== 'function') {
          throw new Error('gzip decompression not supported (DecompressionStream missing)');
        }
        const ds = new DecompressionStream('gzip');
        const decompressed = await new Response(new Blob([u8]).stream().pipeThrough(ds)).arrayBuffer();
        return new Uint8Array(decompressed);
      }

      async function downloadAndMaybeGunzip(url) {
        const resp = await fetch(url, { method: 'GET' });
        if (!resp.ok) {
          throw new Error(`wad download failed: ${resp.status} ${resp.statusText}`);
        }
        const buf = await resp.arrayBuffer();
        const u8 = new Uint8Array(buf);
        if (isProbablyGzip(u8) || String(url).toLowerCase().endsWith('.gz')) {
          return await gunzipBytes(u8);
        }
        return u8;
      }

      function inferDecompressedExtensionFromUrl(url) {
        // Example: .../foo.wad.gz  -> .wad
        //          .../bar.pk3.gz  -> .pk3
        //          .../baz.wad     -> .wad
        // If we can't infer, fall back to .wad.
        try {
          const u = new URL(String(url), window.location.href);
          const name = (u.pathname.split('/').pop() || '').toLowerCase();
          const noGz = name.endsWith('.gz') ? name.slice(0, -3) : name;
          const dot = noGz.lastIndexOf('.');
          if (dot >= 0 && dot < noGz.length - 1) {
            const ext = noGz.slice(dot);
            // Keep it conservative: only allow simple extensions.
            if (/^\.[a-z0-9]{1,8}$/.test(ext)) return ext;
          }
        } catch (_) {
          // ignore
        }
        return '.wad';
      }

      function getIdentityFromUrl() {
        return getParam('identity');
      }

      async function join(serverArg) {
        // serverArg may be either:
        //  - full join URL: https://api.synapse.beebs.dev/room/<uuid>/join
        //  - room UUID: <uuid>
        let arg = '';
        if (serverArg !== undefined && serverArg !== null) {
          arg = String(serverArg);
        }
        if (!arg) {
          const fromUrl = getGameIdFromUrl();
          if (fromUrl) arg = fromUrl;
        }
        if (!arg) {
          throw new Error('missing game id (use ?q=<uuid>)');
        }

        const joinUrl = (arg.startsWith('http://') || arg.startsWith('https://'))
          ? arg
          : `https://api.dorch.beebs.dev/auth/${arg}`;

        // If ?name=<name> is present, forward it to the join API.
        let finalJoinUrl = joinUrl;
        try {
          const name = getIdentityFromUrl();
          if (name) {
            const u = new URL(joinUrl);
            u.searchParams.set('identity', name);
            finalJoinUrl = u.toString();
          }
        } catch (_) {
          // Ignore URL parsing issues.
        }

        const resp = await fetch(finalJoinUrl, { method: 'GET' });
        if (!resp.ok) {
          throw new Error(`join failed: ${resp.status} ${resp.statusText}`);
        }
        const json = await resp.json();
        if (!json || typeof json.token !== 'string' || typeof json.url !== 'string') {
          throw new Error('join response missing token/url');
        }
        return { token: json.token, url: json.url };
      }

      function resizeCanvas(module) {
        // IMPORTANT:
        // Zandronum's SDL path typically renders at a fixed internal resolution
        // (often 640x480) and blits to the canvas at (0,0). If we resize the canvas
        // backing buffer dynamically, the game may only draw into the top-left
        // portion after a resize.
        //
        // To guarantee “stretched fullscreen” behavior on resize, we only enforce
        // full-viewport *CSS sizing* here and let the engine keep its chosen
        // backing-buffer resolution.
        canvas.style.position = 'fixed';
        canvas.style.inset = '0';
        canvas.style.width = '100vw';
        canvas.style.height = '100vh';
      }

      let resizeRaf = 0;
      function scheduleResize(module) {
        if (resizeRaf) return;
        resizeRaf = requestAnimationFrame(() => {
          resizeRaf = 0;
          resizeCanvas(module);
        });
      }

      async function main() {
        if (!window.LivekitClient) {
          throw new Error('LiveKit SDK failed to load (LivekitClient global missing).');
        }
        if (typeof window.createZandronumModule !== 'function') {
          throw new Error('Emscripten module factory missing (createZandronumModule).');
        }

        // Before attempting to initialize the game or connect over WebRTC,
        // fetch game info (routed to the master crate; response is a GameSummary JSON).
        const joinArg = getGameIdFromUrl();
        const gameId = getGameIdForInfoOrThrow(joinArg);
        const gameInfoJson = await fetchGameInfo(gameId);
        const wadIds = extractWadIdsFromGameInfoJson(gameInfoJson);
        const wadUrlsResp = await resolveWadUrls(wadIds);

        // Map wad_id -> url for fast lookup.
        const urlByWadId = new Map();
        for (const item of (wadUrlsResp?.items || [])) {
          if (item && typeof item.wad_id === 'string' && typeof item.url === 'string') {
            urlByWadId.set(item.wad_id, item.url);
          }
        }

        // Determine IWAD vs PWAD IDs based on game info (prefer root.*; fallback info.*).
        const root = gameInfoJson && typeof gameInfoJson === 'object' ? gameInfoJson : {};
        const infoObj = root.info && typeof root.info === 'object' ? root.info : null;
        const iwadId = (typeof root.iwad === 'string' && root.iwad) ? root.iwad
          : (infoObj && typeof infoObj.iwad === 'string' ? infoObj.iwad : null);
        const pwadIds = Array.isArray(root.files) ? root.files
          : (infoObj && Array.isArray(infoObj.files) ? infoObj.files : []);

        if (!iwadId) {
          throw new Error('game info missing iwad UUID');
        }

        // Download + decompress all required WADs before starting the engine.
        setHud('Downloading WADs…');
        const wadBytesById = new Map();
        const wadPathById = new Map();
        const allIds = [iwadId, ...pwadIds];
        for (const id of allIds) {
          const url = urlByWadId.get(id);
          if (!url) {
            throw new Error(`missing resolved URL for wad_id=${id}`);
          }
          const bytes = await downloadAndMaybeGunzip(url);
          wadBytesById.set(id, bytes);
          const ext = inferDecompressedExtensionFromUrl(url);
          wadPathById.set(id, `/wads/${id}${ext}`);
        }

        // Paths we will write into the Emscripten FS.
        const iwadPath = wadPathById.get(iwadId);
        const pwadPaths = pwadIds.map((id) => wadPathById.get(id));

        if (!iwadPath) {
          throw new Error('failed to determine IWAD path');
        }
        for (let i = 0; i < pwadPaths.length; i++) {
          if (!pwadPaths[i]) {
            throw new Error(`failed to determine PWAD path for wad_id=${pwadIds[i]}`);
          }
        }

        setHud('Joining room…');
        const { token, url } = await join(joinArg);

        setHud('Connecting WebRTC…');
        const room = new LivekitClient.Room({});

        // Promise that resolves on the first user gesture.
        let resolveFirstGesture;
        const firstGesture = new Promise((resolve) => { resolveFirstGesture = resolve; });

        // Chrome blocks audio + pointer lock until a user gesture.
        // Keep a persistent pointer handler so we can re-capture mouse after blur.
        let inputHandlersInstalled = false;
        let currentModule = null;

        function updatePointerLockUi() {
          const locked = document.pointerLockElement === canvas;
          canvas.style.cursor = locked ? 'none' : 'default';
        }

        function installInputHandlers() {
          if (inputHandlersInstalled) return;
          inputHandlersInstalled = true;

          document.addEventListener('pointerlockchange', updatePointerLockUi);
          updatePointerLockUi();

          const handler = async () => {
            try {
              canvas.focus?.();
            } catch (_) {}

            // Pointer lock for mouse capture.
            try {
              if (!document.pointerLockElement && canvas.requestPointerLock) {
                canvas.requestPointerLock();
              }
            } catch (_) {}

            // LiveKit audio (optional).
            try {
              await room.startAudio?.();
            } catch (_) {}

            // SDL/WebAudio (Emscripten): best-effort resume.
            try {
              const mod = currentModule;
              const ctx = mod?.SDL2?.audioContext || mod?.SDL?.audioContext || window.SDL2?.audioContext;
              if (ctx && ctx.state === 'suspended' && typeof ctx.resume === 'function') {
                await ctx.resume();
              }
            } catch (_) {}

            if (resolveFirstGesture) {
              try { resolveFirstGesture(); } catch (_) {}
              resolveFirstGesture = null;
            }
          };

          // Not once: we need to re-acquire pointer lock after tab blur.
          canvas.addEventListener('pointerdown', handler);
        }

        // Install early so LiveKit connect is always gated.
        installInputHandlers();

        // UDP queue for the WASM side to poll.
        const udpQueue = [];
        const stats = {
          wasmSendCalls: 0,
          wasmRecvCalls: 0,
          lkRecv: 0,
          lkSend: 0,
          lkSendErr: 0,
        };

        function publishUdp(u8, reliable) {
          if (!room || !room.localParticipant) return false;
          const dest = ['server'];

          // Preferred signature (LK v2): publishData(data, { reliable, topic, destinationIdentities })
          try {
            room.localParticipant.publishData(u8, {
              reliable: !!reliable,
              topic: 'udp',
              destinationIdentities: dest,
            });
            stats.lkSend++;
            return true;
          } catch (_) {
            // Fall through.
          }

          // Fallback signature:
          // publishData(data, kind, options)
          const kind = reliable
            ? LivekitClient.DataPacket_Kind.RELIABLE
            : LivekitClient.DataPacket_Kind.LOSSY;
          try {
            room.localParticipant.publishData(u8, kind, {
              topic: 'udp',
              destinationIdentities: dest,
            });
            stats.lkSend++;
            return true;
          } catch (_) {
            // Fall back to broadcasting.
          }
          try {
            room.localParticipant.publishData(u8, kind, { topic: 'udp' });
            stats.lkSend++;
            return true;
          } catch (_) {
            stats.lkSendErr++;
            return false;
          }
        }

        room.on(LivekitClient.RoomEvent.DataReceived, (payload, participant, kind, topic) => {
          // Some LiveKit publishData overloads may omit topic on the receiver.
          // Treat missing topic as UDP for this app.
          if (topic && topic !== 'udp') return;
          if ((participant?.identity ?? '') !== 'server') return;
          // payload is Uint8Array
          udpQueue.push(payload);
          stats.lkRecv++;
        });

        setHud('Click to start…');
        await firstGesture;
        setHud('Connecting WebRTC…');
        await room.connect(url, token);

        const debugEnabled = getParam('debug') === '1';

        if (debugEnabled) {
          // If this never prints, the engine likely blocks the JS event loop.
          setTimeout(() => console.log('debug: event loop still alive (pre-callMain)'), 1000);
        }

        // Debug-only: verify that LiveKit data packets reach the server/proxy
        // even if the engine never calls into the UDP bridge.
        if (debugEnabled) {
          try {
            const bytes = new TextEncoder().encode('zan-debug-ping');
            const ok = publishUdp(bytes, true);
            console.log('debug: sent zan-debug-ping ok=', ok);
          } catch (e) {
            console.warn('debug: failed to send zan-debug-ping', e);
          }
        }

        // JS transport surface consumed by src/network.cpp (EM_JS hooks).
        // IMPORTANT: this Zandronum build is MODULARIZE'd, so the C++ EM_JS
        // hooks see the *module instance*, not window.Module.
        // We attach __zanRtc onto the module instance via the factory options
        // passed to createZandronumModule().
        const zanRtc = {
          debug: debugEnabled,
          recvUdp() {
            stats.wasmRecvCalls++;
            return udpQueue.length ? udpQueue.shift() : null;
          },
          sendUdp(u8, reliable) {
            stats.wasmSendCalls++;
            publishUdp(u8, !!reliable);
          },
        };

        setHud('Starting game…');

        function tryDecodeCStringPtr(mod, ptr) {
          try {
            if (!mod || typeof ptr !== 'number' || !Number.isFinite(ptr) || ptr <= 0) return null;
            const heap = mod.HEAPU8;
            if (!heap) return null;
            // Heuristic: treat ptr as pointer to a null-terminated UTF-8 string.
            const maxLen = 4096;
            let end = ptr;
            const maxEnd = Math.min(heap.length, ptr + maxLen);
            while (end < maxEnd && heap[end] !== 0) end++;
            if (end === ptr) return '';
            if (end >= heap.length) return null;
            return new TextDecoder('utf-8', { fatal: false }).decode(heap.subarray(ptr, end));
          } catch (_) {
            return null;
          }
        }

        const zand = await window.createZandronumModule({
          noInitialRun: true,
          __zanRtc: zanRtc,
          canvas,
          onAbort: (what) => {
            const decoded = tryDecodeCStringPtr(zand, what);
            console.error('Zandronum abort:', what, typeof what, decoded ? `decoded="${decoded}"` : '');
          },
          quit: (status, toThrow) => {
            console.error('Zandronum quit:', { status, toThrowType: typeof toThrow, toThrow });
            throw toThrow;
          },
          preRun: [
            function () {
              try {
                // Ensure a writable home + XDG-ish config base exists.
                // Zandronum uses NicePath("~/.config/") on Unix.
                if (typeof FS !== 'undefined' && FS.mkdir) {
                  try { FS.mkdir('/home'); } catch (_) {}
                  try { FS.mkdir('/home/web_user'); } catch (_) {}
                  try { FS.mkdir('/home/web_user/.config'); } catch (_) {}
                  try { FS.mkdir('/wads'); } catch (_) {}

                  try {
                    // Write IWAD/PWAD bytes that we downloaded + decompressed.
                    const iwadBytes = wadBytesById.get(iwadId);
                    if (iwadBytes) FS.writeFile(iwadPath, iwadBytes);
                    for (let i = 0; i < pwadIds.length; i++) {
                      const id = pwadIds[i];
                      const p = pwadPaths[i];
                      const b = wadBytesById.get(id);
                      if (b) FS.writeFile(p, b);
                    }
                  } catch (e) {
                    console.error('Failed to write WADs into FS:', e);
                    throw e;
                  }
                }
              } catch (_) {}
            },
          ],
          print: (t) => {
            if (t !== undefined && t !== null && String(t).trim()) {
              console.log(String(t));
            }
          },
          printErr: (t) => {
            if (t !== undefined && t !== null && String(t).trim()) {
              console.error(String(t));
            }
          },
        });

        // Give input handlers access to the module instance (for resuming SDL audio).
        currentModule = zand;

        if (debugEnabled) {
          try {
            const hasFs = !!zand.FS;
            const pk3Path = '/zandronum.pk3';
            const iwadExists = hasFs ? !!zand.FS.analyzePath(iwadPath).exists : false;
            const pk3Exists = hasFs ? !!zand.FS.analyzePath(pk3Path).exists : false;
            console.log('debug: FS available=', hasFs, 'iwadExists=', iwadExists, 'pk3Exists=', pk3Exists);
            if (!iwadExists) {
              console.warn('debug: missing IWAD at', iwadPath);
            }
          } catch (e) {
            console.warn('debug: FS check failed', e);
          }
        }

        // IMPORTANT: do this synchronously before callMain() (which may block the event loop).
        resizeCanvas(zand);
        window.addEventListener('resize', () => scheduleResize(zand));
        window.addEventListener('orientationchange', () => scheduleResize(zand));
        window.addEventListener('fullscreenchange', () => scheduleResize(zand));
        // visualViewport helps on mobile where the URL bar affects layout.
        window.visualViewport?.addEventListener('resize', () => scheduleResize(zand));

        // Kick off the engine in client mode. The IP is a dummy; UDP is bridged over WebRTC.
        // Use the downloaded IWAD/PWADs we wrote into the Emscripten FS.
        try {
          const args = [];
          args.push('-iwad', iwadPath);
          for (const p of pwadPaths) {
            args.push('-file', p);
          }
          args.push(
            '-connect',
            '127.0.0.1',
            // Default volumes in Zandronum are pretty loud for the web client.
            // Users can still override these in the in-game menus.
            '+set',
            'snd_sfxvolume',
            '0.25',
            '+set',
            'snd_musicvolume',
            '0.25',
          );
          console.log('Starting Zandronum with args:', args);
          zand.callMain(args);
        } catch (e) {
          const decoded = tryDecodeCStringPtr(zand, e);
          console.error('callMain threw:', e, typeof e, decoded ? `decoded="${decoded}"` : '');
          throw e;
        }

        if (debugEnabled) {
          // If this never prints, callMain likely never returns (busy loop / no emscripten main loop integration).
          setTimeout(() => console.log('debug: event loop still alive (post-callMain)'), 1000);
        }

        // Minimal on-screen diagnostic (only if ?debug=1).
        if (debugEnabled) {
          setInterval(() => {
            let cssSize = 'unknown';
            try {
              const r = canvas.getBoundingClientRect();
              cssSize = `${Math.round(r.width)}x${Math.round(r.height)}`;
            } catch (_) {}
            const dpr = Math.max(1, Number(window.devicePixelRatio) || 1);
            setHud(
              `css=${cssSize} buf=${canvas.width}x${canvas.height} dpr=${dpr.toFixed(2)}\n` +
              `wasmSend=${stats.wasmSendCalls} wasmRecv=${stats.wasmRecvCalls} lkSend=${stats.lkSend} lkSendErr=${stats.lkSendErr} lkRecv=${stats.lkRecv} udpQueue=${udpQueue.length}`
            );
          }, 250);
        } else {
          setHud('');
        }
      }

      main().catch((e) => {
        const msg = e?.stack || String(e);
        setHud(String(msg));
        console.error('main() rejected:', e, typeof e);
      });
    </script>
  </body>
</html>
